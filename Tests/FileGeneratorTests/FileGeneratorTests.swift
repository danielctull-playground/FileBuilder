
import FileGenerator
import XCTest

final class FileGeneratorTests: XCTestCase {

    func testGeneration() {
        let value = 1
        let file = FileContent(indentation: .spaces(2)) {
            "Hello"
            Section(header: "Header", footer: "Footer") {
                NoContent()
                "Line 1.1"
                Group {
                    "Indented"
                    "Together"
                }
                .indented()
                Section(header: "Header 2") {
                    for i in 1...5 {
                        "Line 2.\(i)"
                    }
                    if true {
                        "Optional"
                    }
                    if value == 0 {
                        "True"
                    } else {
                        "False"
                    }
                }
                "Line 1.2"
            }
            "World"
        }

        XCTAssertEqual(file.content, """
        Hello
        Header
          Line 1.1
            Indented
            Together
          Header 2
            Line 2.1
            Line 2.2
            Line 2.3
            Line 2.4
            Line 2.5
            Optional
            False
          Line 1.2
        Footer
        World
        """)
    }
}

extension String {

    func lowercaseFirstCharacter() -> String {
        guard let first = first else { return self }
        var string = self
        string.replaceSubrange(
            string.startIndex..<string.index(string.startIndex, offsetBy: 1),
            with: first.lowercased())
        return string
    }
}

func foo() throws {

    let arguments = ProcessInfo().arguments
    if arguments.count < 3 {
        print("missing arguments")
        exit(1)
    }

    let (inputPath, outputPath) = (arguments[1], arguments[2])

    var keys: [String] {
        stringsDictionary.keys.sorted().filter { !$0.isEmpty }
    }

    let stringsDictionary: [String: String] = {
        do {
            let stringsData = try Data(contentsOf: URL(fileURLWithPath: inputPath))
            let plistObject = try PropertyListSerialization.propertyList(from: stringsData, format: nil)
            guard let stringsDictionary = plistObject as? [String: String] else {
                print("Failed to parse strings file — is it valid?")
                exit(1)
            }
            return stringsDictionary
        } catch {
            print("Failed to parse strings file — is it valid?")
            exit(1)
        }
    }()

    struct Zilch: Content {
        var body: some Content {
            NoContent()
        }
    }

//    let ambiguous = FileContent(indentation: .tab) {
//        if 1 == 1 {
//            NoContent()
//        } else {
//            ""
//        }
//    }

    let ok = FileContent(indentation: .tab) {
        switch ["", ""].count {
        case 0:
            NoContent()
        case 1:
            NoContent()
        default:
            NoContent()
        }
    }

    var generatedCode: [String] = [
        "import Foundation",
        "import SwiftUI",
        "",
        "// This file was autogenerated — do not modify.",
        ""
    ]



    let tableName = URL(fileURLWithPath: inputPath).deletingPathExtension().lastPathComponent

    // First, let's make some SwiftUI keys.
    generatedCode.append("extension LocalizedStringKey {")

    for key in stringsDictionary.keys.sorted() {
        guard !key.isEmpty else { continue }
        let keyComponents: [String] = key.components(separatedBy: " ")
        guard !keyComponents.isEmpty else { continue }
        var keyAsSymbol = keyComponents.first!
        keyAsSymbol.replaceSubrange(keyAsSymbol.startIndex..<keyAsSymbol.index(keyAsSymbol.startIndex, offsetBy: 1),
                                    with: keyAsSymbol.first!.lowercased())

        if keyComponents.count == 1 {
            generatedCode.append("    static let \(keyAsSymbol): LocalizedStringKey = LocalizedStringKey(\"\(key)\")")
        } else {

            let formatComponents = keyComponents.dropFirst(1).filter({ $0.starts(with: "%") })

            // Image func
            let imageParameterList: String = formatComponents.enumerated().map({ "imageValue value\($0.offset): Image" }).joined(separator: ", ")
            generatedCode.append("    static func \(keyAsSymbol)(\(imageParameterList)) -> LocalizedStringKey {")
            generatedCode.append("        var interpolation = LocalizedStringKey.StringInterpolation(literalCapacity: \(1 + formatComponents.count), interpolationCount: \(formatComponents.count))")
            generatedCode.append("        interpolation.appendLiteral(\"\(keyComponents.first!)\")")
            formatComponents.enumerated().forEach({
                generatedCode.append("        interpolation.appendLiteral(\" \")")
                generatedCode.append("        interpolation.appendInterpolation(value\($0.offset))")
            })
            generatedCode.append("        return LocalizedStringKey(stringInterpolation: interpolation)")
            generatedCode.append("    }")

            // String func
            let stringParameterList: String = formatComponents.enumerated().map({ "formatValue value\($0.offset): String" }).joined(separator: ", ")
            generatedCode.append("    static func \(keyAsSymbol)(\(stringParameterList)) -> LocalizedStringKey {")
            generatedCode.append("        var interpolation = LocalizedStringKey.StringInterpolation(literalCapacity: \(1 + formatComponents.count), interpolationCount: \(formatComponents.count))")
            generatedCode.append("        interpolation.appendLiteral(\"\(keyComponents.first!)\")")
            formatComponents.enumerated().forEach({
                generatedCode.append("        interpolation.appendLiteral(\" \")")
                generatedCode.append("        interpolation.appendInterpolation(value\($0.offset))")
            })
            generatedCode.append("        return LocalizedStringKey(stringInterpolation: interpolation)")
            generatedCode.append("    }")
        }
    }

    generatedCode.append("}")
    generatedCode.append("")

    // Next, some plain strings.
    generatedCode.append("struct \(tableName) {")

    for key in stringsDictionary.keys.sorted() {
        guard !key.isEmpty else { continue }
        let keyComponents: [String] = key.components(separatedBy: " ")
        guard !keyComponents.isEmpty else { continue }
        var keyAsSymbol = keyComponents.first!
        keyAsSymbol.replaceSubrange(keyAsSymbol.startIndex..<keyAsSymbol.index(keyAsSymbol.startIndex, offsetBy: 1),
                                    with: keyAsSymbol.first!.lowercased())

        if keyComponents.count == 1 {
            generatedCode.append("    static var \(keyAsSymbol): String {")
            generatedCode.append("        return NSLocalizedString(\"\(key)\", tableName: \"\(tableName)\", comment: \"\")")
            generatedCode.append("    }")
        } else {
            let formatComponents = keyComponents.dropFirst(1).filter({ $0.starts(with: "%") })
            let stringParameterList: String = formatComponents.enumerated().map({ "formatValue value\($0.offset): String" }).joined(separator: ", ")
            let parameterFormatList: String = formatComponents.enumerated().map({ "value\($0.offset)" }).joined(separator: ", ")
            generatedCode.append("    static func \(keyAsSymbol)(\(stringParameterList)) -> String {")
            generatedCode.append("        let string = NSLocalizedString(\"\(key)\", tableName: \"\(tableName)\", comment: \"\")")
            generatedCode.append("        return String(format: string, \(parameterFormatList))")
            generatedCode.append("    }")
        }
    }

    generatedCode.append("}")
    generatedCode.append("")

    // Write out file.
    let output = generatedCode.joined(separator: "\n")
    try output.write(to: URL(fileURLWithPath: outputPath), atomically: true, encoding: .utf8)


}
